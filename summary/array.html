<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <link href="../css/style.css" rel="stylesheet">
</head>

<body>
    <div class="container">
        <h2><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array"
                target="_blank">Array</a></h2>
        <pre class="prettyprint">

        //###############新增 刪除 修改部分###############
        const months = ["Jan", "March", "April", "June"];
        //Array.push() 方法會添加一個或多個元素至陣列的末端，並且回傳陣列的新長度。
        console.log(months.push("OTB")); //最後面新增一筆，且回傳length

        //Array.pop() 方法會移除並回傳陣列的最後一個元素。此方法會改變陣列的長度。
        console.log(months.pop()); //刪除最後一筆，且回傳被刪除的最後一筆

        //Array.unshift() 方法會添加一個或多個元素至陣列的開頭，並且回傳陣列的新長度。
        console.log(months.unshift("DEV")); //最前面新增一筆，且回傳length

        //Array.shift() 方法會移除並回傳陣列的第一個元素。此方法會改變陣列的長度。
        console.log(months.shift()); //刪除最第一筆，且回傳被刪除的第一筆

        //Array.splice() 方法可以藉由刪除既有元素並／或加入新元素來改變一個陣列的內容。  
        //插入
        months.splice(1, 0, "Feb");
        console.log(months);
        //刪除
        months.splice(1, 2); //索引起(含)，索引迄(含)
        console.log(months);
        //刪除
        months.splice(1); //索引起(含)，後面全刪
        console.log(months);

        //###############常用運算部分###############
        const family = [{ name: "Tom", age: 20, "1_": "abc", dogs: ['dog1', 'dog2'] }, { name: "John", age: 30, "1_": "def", dogs: ['dog3', 'dog4'] }, { name: "Marco", age: 40, "1_": "ghi", dogs: ['dog5', 'dog6'] }];
        const nums = [1, 30, 39, 29, 10, 13];

        //Array.forEach()方法對數組的每個元素執行一次給定的函數。
        family.forEach((x, i, arr) => { console.log(x.name, i, arr) });

        //Array.filter() 方法會建立一個給定陣列部分的淺複製，過濾掉未通過所提供函式所實作測試的給定陣列元素。
        console.log(family.filter(x => x.age >= 30)); //顯示大於age >= 30 多筆
        console.log("Thi4s looks5 grea8t!".split('').filter(x => x != parseInt(x)).join('')); //將數字去除
        console.log([1, 2, 'aasf', '1', '123', 123].filter(x => typeof x === 'number')); // 回傳類別為數字

        //Array.map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。
        console.log(nums.map((x) => x * 2)); //array運算
        console.log(nums.map((v, i) => `${++i}: ${v}`)); // v value  , i index
        console.log("camelCasing".split("").map((v, i) => v !== v.toUpperCase() ? v : v = " " + v).join(""));//遇到大寫時多一個空白
        const scramble = (str, arr) => arr.map((_, idx) => str[arr.indexOf(idx)]).join("");//重新排列
        console.log(scramble("abcd", [0, 3, 1, 2]));

        //Array.reduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。
        console.log([1, 2, 3, 4, 4, 2, 3, 1].reduce((a, c) => a += c, 0)); //a accumulator 累加值 , c currentValue 目前值 , 預設值
        console.log("abaCjdf0sfj#Dcjs".split('').reduce((a, c) => { a[c] = (a[c] || 0) + 1; return a; }, {})); //回傳陣列統計次數 
        console.log([1, 2, 4, 6, 32, 343, 767, 1, 23, 10, 334].filter(f => f < 100).reduce((a, b) => a + b, 0)); //小於多少總和

        //Array.reverse() 方法會原地（in place）反轉（reverse）一個陣列。陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。
        console.log('reverse', nums.reverse());
        //Array.toReversed()實例的方法是Array該方法的複製reverse()對應部分。它會傳回一個元素順序相反的新數組。
        console.log('toReversed', nums.toReversed());

        //Array.join() 方法會將陣列（或一個類陣列（array-like）物件）中所有的元素連接、合併成一個字串，並回傳此字串。
        console.log(nums.join('_')); //預設,

        //Array.indexOf() 方法會回傳給定元素於陣列中第一個被找到之索引，若不存在於陣列中則回傳 -1。
        //Array.lastIndexOf() 方法會回傳給定元素於陣列中最後一個被找到之索引，若不存在於陣列中則回傳 -1。搜尋的方向為由陣列尾部向後（即向前）尋找，啟始於 fromIndex。
        //console.log(arr4);
        console.log(nums.indexOf(1));


        //Array.slice() 方法會回傳一個新陣列物件，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。而原本的陣列將不會被修改。   
        console.log(["Banana", "Orange", "Lemon", "Apple", "Mango"].slice(1)); // 淺拷貝(索引起(含) 至最後 至新物件
        console.log(["Banana", "Orange", "Lemon", "Apple", "Mango"].slice(1, 2)); // 淺拷貝索引起(含),索引迄(不含)) 至新物件

        //Array.find() 方法會回傳在提供的陣列中第一個通過所提供測試函式的元素。如果沒有任何值通過測試函式，則回傳 undefined。  
        //Array.findLast() 方法反向迭代數組，並傳回滿足提供的測試函數的第一個元素的值。如果沒有找到對應元素，則傳回undefined。 
        console.log(family.find(x => x.age >= 30));
        //Array.findIndex() 方法將依據提供的測試函式，尋找陣列中符合的元素，並返回其 index（索引）。如果沒有符合的對象，將返回 -1 
        //Array.findLastIndex()方法反向迭代數組，並傳回滿足所提供的測試函數的第一個元素的索引。若沒有找到對應元素，則回傳-1。
        console.log(family.findIndex(x => x.age >= 30));

        //Array.concat() 方法用於合併兩個或更多的陣列。此方法不會改變原有的陣列，而是返回一個新的陣列。
        console.log(nums.concat([999, 888])); // 如果合併為物件會將物件加到陣列裡

        //Array.from() 方法會從類陣列（array-like）或是可迭代（iterable）物件建立一個新的 Array 實體。
        //字串轉陣列
        console.log(Array.from("foo"));//["f", "o", "o"]     
        //陣列再運算
        console.log(Array.from([1, 2, 3], (x) => x + x));//[2, 4, 6]  
        // 產生一個數字序列，有需要產生一個固定大小的陣列時使用
        // 由於陣列的每個位置都初始化為“undefined”，
        // 下面的“v”的值將是“undefined”
        console.log(Array.from({ length: 10 }, (v, i) => Math.pow(2, i))); // 2跑次方 10次     

        //Array.every() 方法測試一個陣列內的所有元素是否都能通過指定函數的測試。它傳回一個布林值。
        const isBelowThreshold = (currentValue) => currentValue < 40;
        console.log(nums.every(isBelowThreshold)); //true

        //Array.some()方法測試數組中是否至少有一個元素通過了由提供的函數實現的測試。如果在陣列中找到一個元素使得提供的函數傳回true，則傳回true；否則傳回false。它不會修改數組。
        const even = (element) => element % 2 === 0;
        console.log('some', nums.some(even)); //true

        //###############較不常用###############

        //Array.fromAsync()靜態方法可以由一個非同步可迭代物件、可迭代物件或類別數組物件建立一個新的、淺拷貝的Array實例。
        Array.fromAsync({
            length: 3,
            0: Promise.resolve('a'),
            1: Promise.resolve('b'),
            2: Promise.resolve('c'),
        }).then((array) => console.log(array));// [1, 2, 3]

        //Array.isArray() 函式會檢查傳入的值是否為一個 Array。
        console.log(Array.isArray([1, 2, 3])); // true
        console.log(Array.isArray({ foo: 123 })); // false
        console.log(Array.isArray("foobar")); // false
        console.log(Array.isArray(undefined)); // false

        //Array.of() 方法會由引數（arguments）的數量來建立一個新的 Array 實體，而不管引數的數量或類型為何。
        //Array.of() 與 Array 建構式之間的不同在於如何處理整數引數：Array.of(7) 會建立一個擁有單個元素—7—的陣列，而 Array(7) 會建立一個 length 屬性值為 7 的空陣列（**註：**這意味著這個陣列有 7 個空缺欄位（empty slots），而非 7 個值為 undefined 的欄位）。
        console.log(Array.of(7));// [7]
        console.log(Array(7)); // [empty × 7]

        //Array.at() 方法接收一個整數值並傳回該索引對應的元素，允許正數和負數。負整數從數組中的最後一個元素開始倒數。
        console.log(nums.at(2));
        console.log(nums[2]);

        //Array.copyWithin() 方法會將陣列中的部分元素進行淺複製，並將其放置於陣列內的另一個位置，同時返回該陣列，但不改變其長度。
        console.log(months.copyWithin(1, 3));//["a", "d", "e", "d", "e"] (要到的索引,拿值索引起(含))  
        console.log(months.copyWithin(0, 2, 4));//["e", "d", "d", "d", "e"] (要到的索引,拿值索引起(含) ,拿值索引迄(不含))

        //Array.entries() 方法會回傳一個新的陣列迭代器物件，其中包含陣列中每個索引的鍵／值對。
        //Array.keys() 方法會回傳一個包含陣列中的每一個索引之鍵（keys）的新 Array Iterator 物件。
        const iterator1 = nums.entries();
        console.log(iterator1.next().value);
        console.log(iterator1.next().value);
        // const iterator2 = arr3.keys();
        // for (const key of iterator2) {
        //     console.log('key', key);
        // }

        //Array.fill() 方法會將陣列中某個範圍內的所有元素更改為靜態值，並回傳修改後的陣列。
        //console.log(arr4);
        console.log(nums.fill(1, 2, 4)); //(填入內容,索引起(含),索引迄(不含))

        //Array.flat() 函數以遞迴方式將特定深度的子陣列重新串接成為一新的陣列
        //Array.flatMap()方法對數組中的每個元素應用給定的回調函數，然後將結果展開一級，並傳回一個新數組。它等價於在呼叫map()方法後再呼叫深度為1 的flat()方法（arr.map(...args).flat()），但比分別呼叫這兩個方法稍微更有效率。
        //console.log(arr5.flat().flat());
        console.log(nums.flat(2)); //2為深度預設1

        //Array.includes() 方法會判斷陣列是否包含特定的元素，並以此來回傳 true 或 false。
        console.log(nums.includes("1"));

        //Array.sort() 方法會*原地（in place）*對一個陣列的所有元素進行排序，並回傳此陣列。排序不一定是穩定的（stable）。預設的排序順序是根據字串的 Unicode 編碼位置（code points）而定。
        //由於依賴執行環境的實作，所以並不能保證排序的時間及空間複雜度。
      </pre>


    </div>
    <script>

        //###############新增 刪除 修改部分###############
        const months = ["Jan", "March", "April", "June"];
        //Array.push() 方法會添加一個或多個元素至陣列的末端，並且回傳陣列的新長度。
        console.log(months.push("OTB")); //最後面新增一筆，且回傳length

        //Array.pop() 方法會移除並回傳陣列的最後一個元素。此方法會改變陣列的長度。
        console.log(months.pop()); //刪除最後一筆，且回傳被刪除的最後一筆

        //Array.unshift() 方法會添加一個或多個元素至陣列的開頭，並且回傳陣列的新長度。
        console.log(months.unshift("DEV")); //最前面新增一筆，且回傳length

        //Array.shift() 方法會移除並回傳陣列的第一個元素。此方法會改變陣列的長度。
        console.log(months.shift()); //刪除最第一筆，且回傳被刪除的第一筆

        //Array.splice() 方法可以藉由刪除既有元素並／或加入新元素來改變一個陣列的內容。  
        //插入
        months.splice(1, 0, "Feb");
        console.log(months);
        //刪除
        months.splice(1, 2); //索引起(含)，索引迄(含)
        console.log(months);
        //刪除
        months.splice(1); //索引起(含)，後面全刪
        console.log(months);

        //###############常用運算部分###############
        const family = [{ name: "Tom", age: 20, "1_": "abc", dogs: ['dog1', 'dog2'] }, { name: "John", age: 30, "1_": "def", dogs: ['dog3', 'dog4'] }, { name: "Marco", age: 40, "1_": "ghi", dogs: ['dog5', 'dog6'] }];
        const nums = [1, 30, 39, 29, 10, 13];

        //Array.forEach()方法對數組的每個元素執行一次給定的函數。
        family.forEach((x, i, arr) => { console.log(x.name, i, arr) });

        //Array.filter() 方法會建立一個給定陣列部分的淺複製，過濾掉未通過所提供函式所實作測試的給定陣列元素。
        console.log(family.filter(x => x.age >= 30)); //顯示大於age >= 30 多筆
        console.log("Thi4s looks5 grea8t!".split('').filter(x => x != parseInt(x)).join('')); //將數字去除
        console.log([1, 2, 'aasf', '1', '123', 123].filter(x => typeof x === 'number')); // 回傳類別為數字

        //Array.map() 方法會建立一個新的陣列，其內容為原陣列的每一個元素經由回呼函式運算後所回傳的結果之集合。
        console.log(nums.map((x) => x * 2)); //array運算
        console.log(nums.map((v, i) => `${++i}: ${v}`)); // v value  , i index
        console.log("camelCasing".split("").map((v, i) => v !== v.toUpperCase() ? v : v = " " + v).join(""));//遇到大寫時多一個空白
        const scramble = (str, arr) => arr.map((_, idx) => str[arr.indexOf(idx)]).join("");//重新排列
        console.log(scramble("abcd", [0, 3, 1, 2]));

        //Array.reduce() 方法將一個累加器及陣列中每項元素（由左至右）傳入回呼函式，將陣列化為單一值。
        console.log([1, 2, 3, 4, 4, 2, 3, 1].reduce((a, c) => a += c, 0)); //a accumulator 累加值 , c currentValue 目前值 , 預設值
        console.log("abaCjdf0sfj#Dcjs".split('').reduce((a, c) => { a[c] = (a[c] || 0) + 1; return a; }, {})); //回傳陣列統計次數 
        console.log([1, 2, 4, 6, 32, 343, 767, 1, 23, 10, 334].filter(f => f < 100).reduce((a, b) => a + b, 0)); //小於多少總和

        //Array.reverse() 方法會原地（in place）反轉（reverse）一個陣列。陣列中的第一個元素變為最後一個，而最後一個元素則變成第一個。
        console.log('reverse', nums.reverse());
        //Array.toReversed()實例的方法是Array該方法的複製reverse()對應部分。它會傳回一個元素順序相反的新數組。
        console.log('toReversed', nums.toReversed());

        //Array.join() 方法會將陣列（或一個類陣列（array-like）物件）中所有的元素連接、合併成一個字串，並回傳此字串。
        console.log(nums.join('_')); //預設,

        //Array.indexOf() 方法會回傳給定元素於陣列中第一個被找到之索引，若不存在於陣列中則回傳 -1。
        //Array.lastIndexOf() 方法會回傳給定元素於陣列中最後一個被找到之索引，若不存在於陣列中則回傳 -1。搜尋的方向為由陣列尾部向後（即向前）尋找，啟始於 fromIndex。
        //console.log(arr4);
        console.log(nums.indexOf(1));


        //Array.slice() 方法會回傳一個新陣列物件，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。而原本的陣列將不會被修改。   
        console.log(["Banana", "Orange", "Lemon", "Apple", "Mango"].slice(1)); // 淺拷貝(索引起(含) 至最後 至新物件
        console.log(["Banana", "Orange", "Lemon", "Apple", "Mango"].slice(1, 2)); // 淺拷貝索引起(含),索引迄(不含)) 至新物件

        //Array.find() 方法會回傳在提供的陣列中第一個通過所提供測試函式的元素。如果沒有任何值通過測試函式，則回傳 undefined。  
        //Array.findLast() 方法反向迭代數組，並傳回滿足提供的測試函數的第一個元素的值。如果沒有找到對應元素，則傳回undefined。 
        console.log(family.find(x => x.age >= 30));
        //Array.findIndex() 方法將依據提供的測試函式，尋找陣列中符合的元素，並返回其 index（索引）。如果沒有符合的對象，將返回 -1 
        //Array.findLastIndex()方法反向迭代數組，並傳回滿足所提供的測試函數的第一個元素的索引。若沒有找到對應元素，則回傳-1。
        console.log(family.findIndex(x => x.age >= 30));

        //Array.concat() 方法用於合併兩個或更多的陣列。此方法不會改變原有的陣列，而是返回一個新的陣列。
        console.log(nums.concat([999, 888])); // 如果合併為物件會將物件加到陣列裡

        //Array.from() 方法會從類陣列（array-like）或是可迭代（iterable）物件建立一個新的 Array 實體。
        //字串轉陣列
        console.log(Array.from("foo"));//["f", "o", "o"]     
        //陣列再運算
        console.log(Array.from([1, 2, 3], (x) => x + x));//[2, 4, 6]  
        // 產生一個數字序列，有需要產生一個固定大小的陣列時使用
        // 由於陣列的每個位置都初始化為“undefined”，
        // 下面的“v”的值將是“undefined”
        console.log(Array.from({ length: 10 }, (v, i) => Math.pow(2, i))); // 2跑次方 10次     

        //Array.every() 方法測試一個陣列內的所有元素是否都能通過指定函數的測試。它傳回一個布林值。
        const isBelowThreshold = (currentValue) => currentValue < 40;
        console.log(nums.every(isBelowThreshold)); //true

        //Array.some()方法測試數組中是否至少有一個元素通過了由提供的函數實現的測試。如果在陣列中找到一個元素使得提供的函數傳回true，則傳回true；否則傳回false。它不會修改數組。
        const even = (element) => element % 2 === 0;
        console.log('some', nums.some(even)); //true

        //###############較不常用###############

        //Array.fromAsync()靜態方法可以由一個非同步可迭代物件、可迭代物件或類別數組物件建立一個新的、淺拷貝的Array實例。
        Array.fromAsync({
            length: 3,
            0: Promise.resolve('a'),
            1: Promise.resolve('b'),
            2: Promise.resolve('c'),
        }).then((array) => console.log(array));// [1, 2, 3]

        //Array.isArray() 函式會檢查傳入的值是否為一個 Array。
        console.log(Array.isArray([1, 2, 3])); // true
        console.log(Array.isArray({ foo: 123 })); // false
        console.log(Array.isArray("foobar")); // false
        console.log(Array.isArray(undefined)); // false

        //Array.of() 方法會由引數（arguments）的數量來建立一個新的 Array 實體，而不管引數的數量或類型為何。
        //Array.of() 與 Array 建構式之間的不同在於如何處理整數引數：Array.of(7) 會建立一個擁有單個元素—7—的陣列，而 Array(7) 會建立一個 length 屬性值為 7 的空陣列（**註：**這意味著這個陣列有 7 個空缺欄位（empty slots），而非 7 個值為 undefined 的欄位）。
        console.log(Array.of(7));// [7]
        console.log(Array(7)); // [empty × 7]

        //Array.at() 方法接收一個整數值並傳回該索引對應的元素，允許正數和負數。負整數從數組中的最後一個元素開始倒數。
        console.log(nums.at(2));
        console.log(nums[2]);

        //Array.copyWithin() 方法會將陣列中的部分元素進行淺複製，並將其放置於陣列內的另一個位置，同時返回該陣列，但不改變其長度。
        console.log(months.copyWithin(1, 3));//["a", "d", "e", "d", "e"] (要到的索引,拿值索引起(含))  
        console.log(months.copyWithin(0, 2, 4));//["e", "d", "d", "d", "e"] (要到的索引,拿值索引起(含) ,拿值索引迄(不含))

        //Array.entries() 方法會回傳一個新的陣列迭代器物件，其中包含陣列中每個索引的鍵／值對。
        //Array.keys() 方法會回傳一個包含陣列中的每一個索引之鍵（keys）的新 Array Iterator 物件。
        const iterator1 = nums.entries();
        console.log(iterator1.next().value);
        console.log(iterator1.next().value);
        // const iterator2 = arr3.keys();
        // for (const key of iterator2) {
        //     console.log('key', key);
        // }

        //Array.fill() 方法會將陣列中某個範圍內的所有元素更改為靜態值，並回傳修改後的陣列。
        //console.log(arr4);
        console.log(nums.fill(1, 2, 4)); //(填入內容,索引起(含),索引迄(不含))

        //Array.flat() 函數以遞迴方式將特定深度的子陣列重新串接成為一新的陣列
        //Array.flatMap()方法對數組中的每個元素應用給定的回調函數，然後將結果展開一級，並傳回一個新數組。它等價於在呼叫map()方法後再呼叫深度為1 的flat()方法（arr.map(...args).flat()），但比分別呼叫這兩個方法稍微更有效率。
        //console.log(arr5.flat().flat());
        console.log(nums.flat(2)); //2為深度預設1

        //Array.includes() 方法會判斷陣列是否包含特定的元素，並以此來回傳 true 或 false。
        console.log(nums.includes("1"));

        //Array.sort() 方法會*原地（in place）*對一個陣列的所有元素進行排序，並回傳此陣列。排序不一定是穩定的（stable）。預設的排序順序是根據字串的 Unicode 編碼位置（code points）而定。
        //由於依賴執行環境的實作，所以並不能保證排序的時間及空間複雜度。


    </script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
        integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.min.js"
        integrity="sha384-G/EV+4j2dNv+tEPo3++6LCgdCROaejBqfUeNjuKAiuXbjrxilcCdDz6ZAVfHWe1Y"
        crossorigin="anonymous"></script>
    <script src='https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js'></script>
    <script src="../js/nav.js"></script>
</body>

</html>